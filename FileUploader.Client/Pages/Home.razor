@page "/"
@using FileUploader.Common.Communication
@inject HttpClient Http
@inject IJSRuntime JS

<PageTitle>Files</PageTitle>

<FileUploader.Client.Shared.UploadInput OnNewFile="RefreshFiles"></FileUploader.Client.Shared.UploadInput>

<br />
<h1>All public Files:</h1>


@if (files == null)
{
    <p>Loading files...</p>
}
else if (files.Count == 0)
{
    <p>No files available.</p>
}
else
{
    <ul class="file-list">
        @foreach (var file in files)
        {
            <li class="file-item">
                <div class="file-info">
                    <span class="file-name">@file.FileName</span>
                    <span class="file-size">(@file.Size bytes)</span>
                    <span class="file-extension">.@file.Extension</span>
                </div>
                <button class="download-btn" @onclick="() => DownloadFile(file.RelativePath)">Download</button>
            </li>
        }
    </ul>
}

@code {
    private List<UploadResult> files;

    protected override async Task OnInitializedAsync()
    {
        await RefreshFiles();
    }

    private async Task RefreshFiles()
    {
        files = await Http.GetFromJsonAsync<List<UploadResult>>("/files/publicFiles");
    }

    private async Task DownloadFile(string relativePath)
    {
        string apiUrl = $"/files/download?filePath={relativePath}";

        HttpResponseMessage response = await Http.GetAsync(apiUrl);

        if (response.IsSuccessStatusCode)
        {
            byte[] fileBytes = await response.Content.ReadAsByteArrayAsync();
            string fileName = response.Content.Headers.ContentDisposition?.FileName;

            await JS.InvokeVoidAsync("downloadMyFile", fileBytes, fileName);
        }
        else
        {
            Console.WriteLine($"Failed to download file: {response.StatusCode}");   //TODO handle file not found
        }
    }
}
